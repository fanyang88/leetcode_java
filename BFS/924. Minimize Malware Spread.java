/*
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
*/


/*
    infected are 1,3,5
        0 --- 1        /  6
        |     |      5    |
        3- 4 -6        \  7
如果我们什么不操作，那么最终图上所有的节点都会被感染。
那我们现在想删一个初始感染节点，应该怎么去选呢？
假设删除1，最终左边这个连通子图还是会全部被感染，因为3是感染节点
删除3同删除1
假设删除5,可以使右边这个连通子图的所有节点不被感染，成功使感染节点少了3个

我们很容易发现，如果在一个连通子图里面，有两个或两个以上的节点初始被感染，那么无论我们删除哪个都对最后结果没有影响。我们唯一能使感染节点减少的操作就是删除那些只有一个感染节点的连通子图中的感染节点。

since we can only remove one node
所以整个代码的逻辑应该如下：
找到一个连通子图
判断子图中感染节点的数量，若为1，执行第三步；反之执行第一步
计算该子图的长度，长度越长，就越可以最小化感染节点的数量
*/

class Solution {
  public int minMalwareSpread(int[][] graph, int[] initial) {
      Set<Integer> infected = new HashSet<>();
      int minV = Integer.MAX_VALUE, ans = -1;
      for(int n: initial) infected.add(n);
      for(int i=0; i<initial.length; i++) {
          int cleanNode = initial[i];
          infected.remove(cleanNode);
          int amount = bfs(infected, graph);
          // if the amount is large, means more nodes get infected, we want the smallest infected.
          if(amount < minV || (amount==minV && cleanNode < ans)) {
              ans = cleanNode;
              minV = amount;
          }
          infected.add(cleanNode);
      }
      return ans;
  }
  
  public int bfs(Set<Integer> infected, int[][] graph) {
      Set<Integer> copyInfected = new HashSet<>(infected);
      Queue<Integer> q= new LinkedList<>();
      for(int i: copyInfected) q.add(i);
      while(!q.isEmpty()) {
          int cur = q.poll();
          for(int j=0; j<graph[cur].length; j++) {
              if(graph[cur][j]==1 && !copyInfected.contains(j)) {
                  copyInfected.add(j);
                  q.add(j);
              }
          }
      }
      return copyInfected.size();
  }
}

